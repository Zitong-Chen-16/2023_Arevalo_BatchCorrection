'''Visualize method rankings'''
from functools import partial

from matplotlib import pyplot as plt
from matplotlib.figure import Figure
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objs as go

from .colors import METHOD_CMAP, METHOD_SMAP, METHOD_FMT


class Ranker:
    '''Class to generate scatter plot of multiple methods for scores'''

    def __init__(self, scores: pd.DataFrame, measure='mean', sortby_l2=True):
        '''Calculate central tendency of scores and sort methods by L2 norm for
        Bio and batch.  Scores are expected to have the format generated by
        explore_mad_sphering'''
        scores['method'] = scores['method'].map(lambda x: METHOD_FMT.get(x, x))
        measures = scores.groupby(['method', 'dimension'],
                                  as_index=False).score.agg(measure)
        centers = measures.pivot(index='method',
                                 columns='dimension',
                                 values='score')
        if sortby_l2:
            centers['norm'] = centers.apply(np.linalg.norm, axis=1)
            ranklist = centers['norm'].sort_values(ascending=False).index
        else:
            ranklist = centers.T.mean().sort_values(ascending=False).index

        rankmap = dict(zip(ranklist, range(ranklist.size)))

        colors = dict(zip(ranklist, px.colors.qualitative.Plotly))
        centers['color'] = centers.index.map(colors)

        measures_batch = measures.query('dimension=="batch"').set_index(
            'method').score
        measures_bio = measures.query('dimension=="bio"').set_index(
            'method').score

        bio = scores[scores['dimension'] == 'bio'].copy()
        bio['x'] = bio['score']
        bio['y'] = bio['method'].map(measures_batch)

        batch = scores[scores['dimension'] == 'batch'].copy()
        batch['x'] = batch['method'].map(measures_bio)
        batch['y'] = batch['score']
        rank = pd.concat([bio, batch]).reset_index(drop=True)

        rank['rank'] = rank['method'].map(rankmap)
        rank = rank.sort_values(by='rank')

        minmax = scores.groupby(['method', 'dimension']).score.agg([min, max])

        self.rank = rank
        self.ranklist = ranklist
        self.colors = colors
        self.centers = centers
        self.scores = scores
        self.minmax = minmax

    def _create_traces(self, method, row):
        x_min, x_max = self.minmax.loc[method, 'bio']
        y_min, y_max = self.minmax.loc[method, 'batch']
        scatter = partial(go.Scatter,
                          line={
                              'color': row['color'],
                              'width': 1,
                          },
                          legendgroup=method,
                          name=method,
                          hoverinfo='skip',
                          mode='lines',
                          showlegend=False)

        batch_line = scatter(x=[x_min, x_max], y=[row['batch'], row['batch']])
        bio_line = scatter(x=[row['bio'], row['bio']], y=[y_min, y_max])

        traces = batch_line, bio_line
        return traces

    def get_plotly_fig(self, default: str | list[str] | None = None):
        '''Plot Rank. Enable method with default '''

        fig = px.scatter(self.rank,
                         x='x',
                         y='y',
                         color='method',
                         symbol='method',
                         color_discrete_map=self.colors,
                         hover_data=['metric'],
                         height=600)
        fig = fig.update_traces(marker=dict(size=6),
                                selector=dict(mode='markers'))
        for method, row in self.centers.iterrows():
            traces = self._create_traces(method, row)
            fig.add_traces(traces)

        fig = fig.update_layout(yaxis_range=[0, 1], xaxis_range=[0, 1])

        # Enable default models
        if isinstance(default, str):
            default = [default]
        if default:
            fig = fig.update_traces(visible='legendonly')
            for model_name in default:
                fig = fig.update_traces(visible=True,
                                        selector=dict(name=model_name))
        fig.update_layout(xaxis_title="Bio",
                          yaxis_title="Batch",
                          font=dict(size=18),
                          legend_title_text='Method',
                          legend_itemsizing='constant')

        return fig

    def get_figure(self) -> Figure:
        plt.rcParams.update({'font.size': 14})

        fig, ax = plt.subplots(figsize=(8, 6))
        ax.set_xlim([0, 1])
        ax.set_ylim([0, 1])
        lines = self.rank.groupby('method')[['x', 'y']].describe()
        lines = lines.loc[self.ranklist]
        for method, row in lines.iterrows():
            ax.plot([row.x['min'], row.x['max']],
                    [row.y['mean'], row.y['mean']],
                    color=METHOD_CMAP[method],
                    linewidth=0.5)
            ax.plot([row.x['mean'], row.x['mean']],
                    [row.y['min'], row.y['max']],
                    color=METHOD_CMAP[method],
                    linewidth=0.5)
            ax.scatter(
                self.rank.query('method==@method').x,
                self.rank.query('method==@method').y,
                color=METHOD_CMAP[method],
                marker=METHOD_SMAP[method],
                s=6,
                label=method,
            )
        ax.legend(frameon=False, markerscale=3.5, loc='lower right')
        ax.set_ylabel('Batch')
        ax.set_xlabel('Bio')
        return fig

    @staticmethod
    def plot(scores: pd.DataFrame) -> Figure:
        '''Plot the given score ranks'''
        return Ranker(scores).get_figure()
